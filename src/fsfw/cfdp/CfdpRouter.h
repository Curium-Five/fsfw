#ifndef FSFW_TCDISTRIBUTION_CFDPDISTRIBUTOR_H_
#define FSFW_TCDISTRIBUTION_CFDPDISTRIBUTOR_H_

#include <utility>
#include <vector>

#include "CfdpRouterIF.h"
#include "fsfw/returnvalues/HasReturnvaluesIF.h"
#include "fsfw/tcdistribution/CfdpPacketChecker.h"
#include "fsfw/tcdistribution/TcDistributorBase.h"
#include "fsfw/tmtcpacket/cfdp/CfdpPacketStored.h"
#include "fsfw/tmtcservices/AcceptsTelecommandsIF.h"
#include "fsfw/tmtcservices/VerificationReporter.h"

struct CfdpRouterCfg {
  CfdpRouterCfg(object_id_t objectId, MessageQueueIF& tmQueue)
      : objectId(objectId), tmQueue(tmQueue) {}

  object_id_t objectId;
  MessageQueueIF& tmQueue;
};
/**
 * This will be the primary component to perform PDU forwading procedures. This includes forwarding
 * CFDP TC packets to registered source or destination handlers, and forwarding all telemetry
 * generated by them to registered TM sinks.
 * @ingroup tc_distribution
 */
class CfdpRouter : public TcDistributorBase,
                   public CfdpRouterIF,
                   public AcceptsTelecommandsIF,
                   public AcceptsTelemetryIF {
 public:
  /**
   * The ctor passes @c set_apid to the checker class and calls the
   * TcDistribution ctor with a certain object id.
   * @param setApid The APID of this receiving Application.
   * @param setObjectId Object ID of the distributor itself
   * @param setPacketSource Object ID of the source of TC packets.
   * Must implement CcsdsDistributorIF.
   */
  explicit CfdpRouter(CfdpRouterCfg cfg);

  ReturnValue_t performOperation(uint8_t opCode) override;
  ReturnValue_t performTmHandling();
  [[nodiscard]] const char* getName() const override;
  [[nodiscard]] uint32_t getIdentifier() const override;
  [[nodiscard]] MessageQueueId_t getRequestQueue() const override;
  MessageQueueId_t getReportReceptionQueue(uint8_t virtualChannel) override;
  ReturnValue_t registerTmSink(cfdp::EntityId address, AcceptsTelemetryIF& tmDest) override;
  ReturnValue_t registerTcDestination(cfdp::EntityId address,
                                      AcceptsTelecommandsIF& tcDest) override;

 protected:
  struct EntityInfo {
    EntityInfo(cfdp::EntityId id, const char* name, MessageQueueId_t queueId)
        : id(std::move(id)), name(name), queueId(queueId) {}
    cfdp::EntityId id;
    const char* name;
    MessageQueueId_t queueId;
  };
  ReturnValue_t lastTcError = HasReturnvaluesIF::RETURN_OK;
  ReturnValue_t lastTmError = HasReturnvaluesIF::RETURN_OK;
  // I don't think a regular OBSW will have more than 1 or 2 of these destinations, so I think
  // it is okay to accept the overhead here
  std::vector<EntityInfo> tmDestinations;
  std::vector<EntityInfo> tcDestinations;
  MessageQueueIF& tmQueue;

  ReturnValue_t selectDestination(MessageQueueId_t& destId) override;

 private:
};

#endif /* FSFW_TCDISTRIBUTION_CFDPDISTRIBUTOR_H_ */
